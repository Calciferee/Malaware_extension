    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
        var line = i ? lineView.rest[i - 1] : lineView.line, order = void 0
        builder.pos = 0
        builder.addToken = buildToken
        // Optionally wire in some hacks into the token-rendering
        // algorithm, to deal with browser quirks.
        if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
          { builder.addToken = buildTokenBadBidi(builder.addToken, order) }
        builder.map = []
        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line)
        insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate))
        if (line.styleClasses) {
          if (line.styleClasses.bgClass)
            { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "") }
          if (line.styleClasses.textClass)
            { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "") }
        }
    
        // Ensure at least a single node is present, for measuring.
        if (builder.map.length == 0)
          { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))) }
    
        // Store the map and a cache object for the current logical line
        if (i == 0) {
          lineView.measure.map = builder.map
          lineView.measure.cache = {}
        } else {
          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
          ;(lineView.measure.caches || (lineView.measure.caches = [])).push({})
        }
      }
    
      // See issue #2901
      if (webkit) {
        var last = builder.content.lastChild
        if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
          { builder.content.className = "cm-tab-wrap-hack" }
      }
    
      signal(cm, "renderLine", cm, lineView.line, builder.pre)
      if (builder.pre.className)
        { builder.textClass = joinClasses(builder.pre.className, builder.textClass || "") }
    
      return builder
    }
    
    function defaultSpecialCharPlaceholder(ch) {
      var token = elt("span", "\u2022", "cm-invalidchar")
      token.title = "\\u" + ch.charCodeAt(0).toString(16)
      token.setAttribute("aria-label", token.title)
      return token
    }
    
    // Build up the DOM representation for a single token, and add it to
    // the line map. Takes care to render special characters separately.
    function buildToken(builder, text, style, startStyle, endStyle, title, css) {
      if (!text) { return }
      var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text
      var special = builder.cm.state.specialChars, mustWrap = false
      var content
      if (!special.test(text)) {
        builder.col += text.length
        content = document.createTextNode(displayText)
        builder.map.push(builder.pos, builder.pos + text.length, content)
        if (ie && ie_version < 9) { mustWrap = true }
        builder.pos += text.length
      } else {
        content = document.createDocumentFragment()
        var pos = 0
        while (true) {
          special.lastIndex = pos
          var m = special.exec(text)
          var skipped = m ? m.index - pos : text.length - pos
          if (skipped) {
            var txt = document.createTextNode(displayText.slice(pos, pos + skipped))
            if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])) }
            else { content.appendChild(txt) }
            builder.map.push(builder.pos, builder.pos + skipped, txt)
            builder.col += skipped
            builder.pos += skipped
          }
          if (!m) { break }
          pos += skipped + 1
          var txt$1 = void 0
          if (m[0] == "\t") {
            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize
            txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"))
            txt$1.setAttribute("role", "presentation")
            txt$1.setAttribute("cm-text", "\t")
            builder.col += tabWidth
          } else if (m[0] == "\r" || m[0] == "\n") {
            txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"))
            txt$1.setAttribute("cm-text", m[0])
            builder.col += 1
          } else {
            txt$1 = builder.cm.options.specialCharPlaceholder(m[0])
            txt$1.setAttribute("cm-text", m[0])
            if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])) }
            else { content.appendChild(txt$1) }
            builder.col += 1
          }
          builder.map.push(builder.pos, builder.pos + 1, txt$1)
          builder.pos++
        }
      }
      builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32
      if (style || startStyle || endStyle || mustWrap || css) {
        var fullStyle = style || ""
        if (startStyle) { fullStyle += startStyle }
        if (endStyle) { fullStyle += endStyle }
        var token = elt("span", [content], fullStyle, css)
        if (title) { token.title = title }
        return builder.content.appendChild(token)
      }
      builder.content.appendChild(content)
    }
    
    function splitSpaces(text, trailingBefore) {
      if (text.length > 1 && !/  /.test(text)) { return text }
      var spaceBefore = trailingBefore, result = ""
      for (var i = 0; i < text.length; i++) {
        var ch = text.charAt(i)
        if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
          { ch = "\u00a0" }
        result += ch
        spaceBefore = ch == " "
      }
      return result
    }
    
    // Work around nonsense dimensions being reported for stretches of
    // right-to-left text.
    function buildTokenBadBidi(inner, order) {
      return function (builder, text, style, startStyle, endStyle, title, css) {
        style = style ? style + " cm-force-border" : "cm-force-border"
        var start = builder.pos, end = start + text.length
        for (;;) {
          // Find the part that overlaps with the start of this text
          var part = void 0
          for (var i = 0; i < order.length; i++) {
            part = order[i]
            if (part.to > start && part.from <= start) { break }
          }
          if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
          inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css)
          startStyle = null
          text = text.slice(part.to - start)
          start = part.to
        }
      }
    }
    
    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
      var widget = !ignoreWidget && marker.widgetNode
      if (widget) { builder.map.push(builder.pos, builder.pos + size, widget) }
      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
        if (!widget)
          { widget = builder.content.appendChild(document.createElement("span")) }
        widget.setAttribute("cm-marker", marker.id)
      }
      if (widget) {
        builder.cm.display.input.setUneditable(widget)
        builder.content.appendChild(widget)
      }
      builder.pos += size
      builder.trailingSpace = false
    }  